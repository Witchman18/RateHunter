# =========================================================================
# ===================== RateHunter 2.0 - Alpha v0.2.4 ===================
# =========================================================================
# –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏:
# - –ò–°–ü–†–ê–í–õ–ï–ù–û: –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏ (–õ–û–ù–ì/–®–û–†–¢) —Ç–µ–ø–µ—Ä—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.
# - –ò–°–ü–†–ê–í–õ–ï–ù–û: –í–º–µ—Å—Ç–æ –æ—Ç—Å—á–µ—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è —Ç–æ—á–Ω–æ–µ –≤—Ä–µ–º—è —Ñ–∞–Ω–¥–∏–Ω–≥–∞ (–ú–°–ö).
# =========================================================================

import os
import asyncio
import aiohttp
import decimal
from datetime import datetime, timezone, timedelta # –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω—ã timezone –∏ timedelta
from decimal import Decimal

from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes,
    ConversationHandler, CallbackQueryHandler, filters
)
from dotenv import load_dotenv

load_dotenv()

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
BOT_TOKEN = os.getenv("BOT_TOKEN")
MSK_TIMEZONE = timezone(timedelta(hours=3)) # –ò–ó–ú–ï–ù–ï–ù–û: –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ú–°–ö —Ç–∞–π–º–∑–æ–Ω—É

# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ---
user_settings = {}
api_data_cache = {"last_update": None, "data": []}
CACHE_LIFETIME_SECONDS = 60
ALL_AVAILABLE_EXCHANGES = ['Bybit', 'MEXC', 'Binance', 'OKX', 'KuCoin', 'Gate.io', 'HTX', 'Bitget']

# --- –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler ---
SET_FUNDING_THRESHOLD, SET_VOLUME_THRESHOLD = range(2)

def get_default_settings():
    return {
        'notifications_on': True, 'exchanges': ['Bybit', 'MEXC', 'Binance', 'OKX', 'KuCoin'],
        'funding_threshold': Decimal('0.005'), 'volume_threshold_usdt': Decimal('1000000'),
    }

def ensure_user_settings(chat_id: int):
    if chat_id not in user_settings: user_settings[chat_id] = get_default_settings()
    for key, value in get_default_settings().items():
        user_settings[chat_id].setdefault(key, value)


# =================================================================
# ===================== –ú–û–î–£–õ–¨ –°–ë–û–†–ê –î–ê–ù–ù–´–• (API) =====================
# =================================================================

async def get_bybit_data():
    bybit_url = "https://api.bybit.com/v5/market/tickers?category=linear"
    results = []
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(bybit_url) as response:
                response.raise_for_status()
                data = await response.json()
                if data.get("retCode") == 0 and data.get("result", {}).get("list"):
                    for t in data["result"]["list"]:
                        try:
                            results.append({
                                'exchange': 'Bybit', 'symbol': t.get("symbol"),
                                'rate': Decimal(t.get("fundingRate")), 'next_funding_time': int(t.get("nextFundingTime")),
                                'volume_24h_usdt': Decimal(t.get("turnover24h")), 'max_order_value_usdt': Decimal('0'),
                                'trade_url': f'https://www.bybit.com/trade/usdt/{t.get("symbol")}'
                            })
                        except (TypeError, ValueError, decimal.InvalidOperation): continue
    except Exception as e: print(f"[API_ERROR] Bybit: {e}")
    return results

async def get_mexc_data():
    mexc_url = "https://contract.mexc.com/api/v1/contract/detail"
    results = []
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(mexc_url) as response:
                response.raise_for_status()
                data = await response.json()
                if data.get("success") and data.get("data"):
                    for t in data["data"]:
                         if t.get("quoteCoin") != "USDT" or t.get("state") != "SHOW": continue
                         try:
                            symbol = t.get("symbol").replace("_", "")
                            results.append({
                                'exchange': 'MEXC', 'symbol': symbol,
                                'rate': Decimal(str(t.get("fundingRate"))), 'next_funding_time': int(t.get("nextSettleTime")),
                                'volume_24h_usdt': Decimal(str(t.get("volume24"))), 'max_order_value_usdt': Decimal(str(t.get("maxVol"))),
                                'trade_url': f'https://futures.mexc.com/exchange/{t.get("symbol")}'
                            })
                         except (TypeError, ValueError, decimal.InvalidOperation): continue
    except Exception as e: print(f"[API_ERROR] MEXC: {e}")
    return results

async def fetch_all_data(force_update=False):
    now = datetime.now().timestamp()
    if not force_update and api_data_cache["last_update"] and (now - api_data_cache["last_update"] < CACHE_LIFETIME_SECONDS):
        return api_data_cache["data"]
    tasks = [get_bybit_data(), get_mexc_data()]
    results_from_tasks = await asyncio.gather(*tasks, return_exceptions=True)
    all_data = []
    for res in results_from_tasks:
        if isinstance(res, list): all_data.extend(res)
    api_data_cache["data"], api_data_cache["last_update"] = all_data, now
    return all_data


# =================================================================
# ================== –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨–°–ö–ò–ô –ò–ù–¢–ï–†–§–ï–ô–° (UI) ==================
# =================================================================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    ensure_user_settings(update.effective_chat.id)
    main_menu_keyboard = [["üî• –¢–æ–ø-—Å—Ç–∞–≤–∫–∏ —Å–µ–π—á–∞—Å"], ["üîî –ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã", "‚ÑπÔ∏è –ú–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"]]
    reply_markup = ReplyKeyboardMarkup(main_menu_keyboard, resize_keyboard=True)
    await update.message.reply_text(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ RateHunter 2.0!", reply_markup=reply_markup
    )

async def show_top_rates(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    ensure_user_settings(chat_id)
    settings = user_settings[chat_id]
    message_to_edit = update.callback_query.message if update.callback_query else await update.message.reply_text("üîÑ –ò—â—É...")
    await message_to_edit.edit_text("üîÑ –ò—â—É –ª—É—á—à–∏–µ —Å—Ç–∞–≤–∫–∏ –ø–æ –≤–∞—à–∏–º —Ñ–∏–ª—å—Ç—Ä–∞–º...")
    all_data = await fetch_all_data()
    user_filtered_data = [
        item for item in all_data
        if item['exchange'] in settings['exchanges'] and abs(item['rate']) >= settings['funding_threshold']
        and item['volume_24h_usdt'] >= settings['volume_threshold_usdt']
    ]
    user_filtered_data.sort(key=lambda x: abs(x['rate']), reverse=True)
    top_5 = user_filtered_data[:5]
    if not top_5:
        await message_to_edit.edit_text("üòî –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–∞—Ä, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –≤–∞—à–∏–º —Ñ–∏–ª—å—Ç—Ä–∞–º.")
        return
    message_text = f"üî• **–¢–û–ü-5 —Ñ–∞–Ω–¥–∏–Ω–≥–æ–≤ > {settings['funding_threshold']*100:.2f}%**\n\n"
    buttons = []
    for item in top_5:
        # --- –ò–ó–ú–ï–ù–ï–ù–û: –õ–æ–≥–∏–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –≤—Ä–µ–º–µ–Ω–∏ ---
        symbol_only = item['symbol'].replace("USDT", "")
        funding_dt = datetime.fromtimestamp(item['next_funding_time'] / 1000, tz=MSK_TIMEZONE)
        time_str = funding_dt.strftime('%H:%M –ú–°–ö')
        
        # –ï—Å–ª–∏ —Å—Ç–∞–≤–∫–∞ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è - –ª–æ–Ω–≥–∏—Å—Ç—ã –ø–æ–ª—É—á–∞—é—Ç –¥–µ–Ω—å–≥–∏ (–∑–∞—Ö–æ–¥–∏–º –≤ –õ–û–ù–ì)
        # –ï—Å–ª–∏ —Å—Ç–∞–≤–∫–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–∞—è - —à–æ—Ä—Ç–∏—Å—Ç—ã –ø–æ–ª—É—á–∞—é—Ç –¥–µ–Ω—å–≥–∏ (–∑–∞—Ö–æ–¥–∏–º –≤ –®–û–†–¢)
        direction_text = "üü¢ –õ–û–ù–ì" if item['rate'] < 0 else "üî¥ –®–û–†–¢"
        rate_str = f"{item['rate'] * 100:+.2f}%"
        
        message_text += f"{direction_text} *{symbol_only}* `{rate_str}` –≤ `{time_str}` [{item['exchange']}]\n"
        # -----------------------------------------------
        buttons.append(InlineKeyboardButton(symbol_only, callback_data=f"drill_{item['symbol']}"))
        
    keyboard = [buttons[i:i + 3] for i in range(0, len(buttons), 3)]
    await message_to_edit.edit_text(
        message_text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown', disable_web_page_preview=True
    )
    
async def drill_down_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; await query.answer()
    symbol_to_show = query.data.split('_')[1]
    all_data = api_data_cache.get("data", []);
    if not all_data:
        all_data = await fetch_all_data(force_update=True)
    symbol_specific_data = [item for item in all_data if item['symbol'] == symbol_to_show]
    symbol_specific_data.sort(key=lambda x: abs(x['rate']), reverse=True)
    symbol_only = symbol_to_show.replace("USDT", "")
    message_text = f"üíé **–î–µ—Ç–∞–ª–∏ –ø–æ {symbol_only}**\n\n"
    for item in symbol_specific_data:
        # --- –ò–ó–ú–ï–ù–ï–ù–û: –õ–æ–≥–∏–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –≤—Ä–µ–º–µ–Ω–∏ ---
        funding_dt = datetime.fromtimestamp(item['next_funding_time'] / 1000, tz=MSK_TIMEZONE)
        time_str = funding_dt.strftime('%H:%M –ú–°–ö')
        
        direction_text = "üü¢ –õ–û–ù–ì" if item['rate'] < 0 else "üî¥ –®–û–†–¢"
        rate_str = f"{item['rate'] * 100:+.2f}%"
        
        message_text += f"{direction_text} `{rate_str}` –≤ `{time_str}` [{item['exchange']}]({item['trade_url']})\n"
        # -----------------------------------------------
        
    keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Ç–æ–ø—É", callback_data="back_to_top")]]
    await query.edit_message_text(
        text=message_text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown', disable_web_page_preview=True
    )

async def back_to_top_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await query.answer() if (query := update.callback_query) else None
    await show_top_rates(update, context)

# --- –ë–õ–û–ö: –ú–µ–Ω—é "–ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã" ---

async def send_filters_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    ensure_user_settings(chat_id)
    settings = user_settings[chat_id]
    notif_emoji = "‚úÖ" if settings['notifications_on'] else "üî¥"
    vol = settings['volume_threshold_usdt']
    vol_str = f"{vol / 1_000_000:.1f}M" if vol >= 1_000_000 else f"{vol / 1_000:.0f}K"
    message_text = "üîî **–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π**"
    keyboard = [
        [InlineKeyboardButton("üè¶ –ë–∏—Ä–∂–∏", callback_data="filters_exchanges")],
        [InlineKeyboardButton(f"üîî –°—Ç–∞–≤–∫–∞: > {settings['funding_threshold']*100:.2f}%", callback_data="filters_funding")],
        [InlineKeyboardButton(f"üíß –û–±—ä–µ–º: > {vol_str}", callback_data="filters_volume")],
        [InlineKeyboardButton(f"{notif_emoji} –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {'–í–ö–õ' if settings['notifications_on'] else '–í–´–ö–õ'}", callback_data="filters_toggle_notif")],
        [InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å", callback_data="filters_close")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    if update.callback_query:
        await update.callback_query.edit_message_text(message_text, reply_markup=reply_markup, parse_mode='Markdown')
    else:
        await update.message.reply_text(message_text, reply_markup=reply_markup, parse_mode='Markdown')

async def filters_menu_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await send_filters_menu(update, context)

async def filters_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; await query.answer()
    action = query.data.split('_', 1)[1]
    if action == "close": 
        await query.message.delete()
    elif action == "toggle_notif":
        user_settings[update.effective_chat.id]['notifications_on'] ^= True
        await send_filters_menu(update, context)
    elif action == "exchanges":
        await show_exchanges_menu(update, context)

async def show_exchanges_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    active_exchanges = user_settings[query.message.chat_id]['exchanges']
    buttons = [InlineKeyboardButton(f"{'‚úÖ' if ex in active_exchanges else '‚¨úÔ∏è'} {ex}", callback_data=f"exch_{ex}") for ex in ALL_AVAILABLE_EXCHANGES]
    keyboard = [buttons[i:i + 2] for i in range(0, len(buttons), 2)] + [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="exch_back")]]
    await query.edit_message_text("üè¶ **–í—ã–±–µ—Ä–∏—Ç–µ –±–∏—Ä–∂–∏**", reply_markup=InlineKeyboardMarkup(keyboard))

async def exchanges_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query; await query.answer()
    action = query.data.split('_', 1)[1]
    if action == "back": await send_filters_menu(update, context)
    else:
        active_exchanges = user_settings[query.message.chat_id]['exchanges']
        if action in active_exchanges: active_exchanges.remove(action)
        else: active_exchanges.append(action)
        await show_exchanges_menu(update, context)

async def ask_for_value(update: Update, context: ContextTypes.DEFAULT_TYPE, setting_type: str):
    query = update.callback_query; await query.answer()
    chat_id = update.effective_chat.id
    
    prompts = {
        'funding': (f"–¢–µ–∫—É—â–∏–π –ø–æ—Ä–æ–≥ —Å—Ç–∞–≤–∫–∏: `> {user_settings[chat_id]['funding_threshold']*100:.2f}%`.\n\n"
                    "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, `0.75`)."),
        'volume': (f"–¢–µ–∫—É—â–∏–π –ø–æ—Ä–æ–≥ –æ–±—ä–µ–º–∞: `{user_settings[chat_id]['volume_threshold_usdt']:,.0f} USDT`.\n\n"
                   "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ USDT (–Ω–∞–ø—Ä–∏–º–µ—Ä, `500000`).")
    }
    
    await query.message.delete()
    sent_message = await context.bot.send_message(
        chat_id=chat_id, text=prompts[setting_type] + "\n\n–î–ª—è –æ—Ç–º–µ–Ω—ã –≤–≤–µ–¥–∏—Ç–µ /cancel.", parse_mode='Markdown'
    )
    context.user_data['prompt_message_id'] = sent_message.message_id
    return SET_FUNDING_THRESHOLD if setting_type == 'funding' else SET_VOLUME_THRESHOLD

async def save_value(update: Update, context: ContextTypes.DEFAULT_TYPE, setting_type: str):
    chat_id = update.effective_chat.id
    try:
        value_str = update.message.text.strip().replace(",", ".")
        value = Decimal(value_str)
        if setting_type == 'funding':
            if not (0 < value < 100): raise ValueError("Value out of range 0-100")
            user_settings[chat_id]['funding_threshold'] = value / 100
        elif setting_type == 'volume':
            if value < 0: raise ValueError("Value must be positive")
            user_settings[chat_id]['volume_threshold_usdt'] = value
    except (ValueError, TypeError, decimal.InvalidOperation) as e:
        error_messages = {
            'funding': "‚ùå –û—à–∏–±–∫–∞. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 100 (–Ω–∞–ø—Ä–∏–º–µ—Ä, `0.75`).",
            'volume': "‚ùå –û—à–∏–±–∫–∞. –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `500000`)."
        }
        await update.message.reply_text(error_messages[setting_type] + " –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", parse_mode='Markdown')
        return SET_FUNDING_THRESHOLD if setting_type == 'funding' else SET_VOLUME_THRESHOLD

    # –û—á–∏—Å—Ç–∫–∞
    if 'prompt_message_id' in context.user_data:
        await context.bot.delete_message(chat_id, context.user_data.pop('prompt_message_id'))
    await context.bot.delete_message(chat_id, update.message.message_id)
    
    await send_filters_menu(update, context)
    return ConversationHandler.END

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    if 'prompt_message_id' in context.user_data:
        try:
            await context.bot.delete_message(chat_id, context.user_data.pop('prompt_message_id'))
        except Exception:
            pass 
    try:
        await context.bot.delete_message(chat_id, update.message.id)
    except Exception:
        pass 
    
    await context.bot.send_message(chat_id, "–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    await send_filters_menu(update, context) 
    return ConversationHandler.END

# –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è background_scanner
async def background_scanner(app):
    """–§–æ–Ω–æ–≤—ã–π —Å–∫–∞–Ω–µ—Ä - –∑–∞–≥–ª—É—à–∫–∞"""
    pass

# =================================================================
# ========================== –ó–ê–ü–£–°–ö –ë–û–¢–ê ==========================
# =================================================================
if __name__ == "__main__":
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    
    funding_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(lambda u,c: ask_for_value(u,c,'funding'), pattern="^filters_funding$")],
        states={SET_FUNDING_THRESHOLD: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda u,c: save_value(u,c,'funding'))]},
        fallbacks=[CommandHandler("cancel", cancel_conversation)],
    )
    volume_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(lambda u,c: ask_for_value(u,c,'volume'), pattern="^filters_volume$")],
        states={SET_VOLUME_THRESHOLD: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda u,c: save_value(u,c,'volume'))]},
        fallbacks=[CommandHandler("cancel", cancel_conversation)],
    )
    
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.Regex("^üî• –¢–æ–ø-—Å—Ç–∞–≤–∫–∏ —Å–µ–π—á–∞—Å$"), show_top_rates))
    app.add_handler(MessageHandler(filters.Regex("^üîî –ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã$"), filters_menu_entry))
    
    app.add_handler(funding_conv)
    app.add_handler(volume_conv)

    app.add_handler(CallbackQueryHandler(drill_down_callback, pattern="^drill_"))
    app.add_handler(CallbackQueryHandler(back_to_top_callback, pattern="^back_to_top$"))
    app.add_handler(CallbackQueryHandler(filters_callback_handler, pattern="^filters_(close|toggle_notif|exchanges)$"))
    app.add_handler(CallbackQueryHandler(exchanges_callback_handler, pattern="^exch_"))
    
    async def post_init(app): asyncio.create_task(background_scanner(app))
    app.post_init = post_init
    
    print("Bot is running...")
    app.run_polling()
